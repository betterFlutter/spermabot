# Планировщик «Хронос»: алгоритм жадного эвристического динамического слот-планировщика мемов с адаптацией нагрузки 
---



## 0) Абстракт:
Цель алгоритма — быть «чёрной коробкой»: на вход он принимает пост(ы), внутри сам планирует время публикации, а на выходе отдаёт дату и время, формируя отложку.
Админы в большинстве своём существа очень ленивые и тупые. Цель алгоритма делать то, что должны делать админы. Теперь от нас, как от админов, не требуется ничего, кроме как нажать «одобрить мем» и всё. Дальше алгоритм сам: понимает среднюю норму постинга на канале за последние 2 недели, строит план на несколько дней вперёд и правит его на лету в зависимости от того, сколько постов уже лежит в отложке.
Алгоритм старается делать оптимальный план вне зависимости от количества предложенных постов в день. Он должен работать одинаково хорошо и при маленьком потоке, и при большом: учитывать это, формировать ожидания и раскладывать публикации на несколько дней вперёд на основе реальной нагрузки.
Важно одновременно балансировать между ожиданием авторов постов и стабильностью планирования. Если сделать так, что подписчики будут ждать по несколько дней с момента принятия мема до публикации, мы получим стабильный «ламинарный» план: не будет такого, что в один день вышел 1 мем, а в другой — 10. Но появится другая проблема: авторы будут ждать сутками и злиться. Обезьянка грустит — обезьянке плохо.

Если же, наоборот, пытаться публиковать всё максимально быстро, легко получаются качели: сегодня 1 пост, завтра 10. Этот алгоритм пытается держать баланс: без ручной настройки он оценивает норму по двухнедельному периоду и по последним 3 дням, усредняет и получает адекватную «среднюю норму на день». При этом он почти никогда не заставляет авторов ждать больше суток от момента принятия до публикации — вне зависимости от загруженности предложки. Для этого есть резервные места.





---

## 1) Введение

В боте есть два способа планировать публикации:

1. **Instant-режим** — публикуем сразу (без сетки времени).
2. **Планировщик по сетке** — выставляем `scheduled_at` (время публикации) и дальше отдельный цикл публикует пост, когда время наступило.

Планировщик по сетке бывает **двух режимов**:

- `static` — «первый свободный слот по сетке».
- `dynamic` — «динамический алгоритм»: распределяет посты по слотам, стараясь:
  - не забивать день сверх доступных слотов,
  - ускорять очередь, если она копится долго,
  - делать публикации более «справедливыми» между авторами (не давать одному автору подряд и слишком часто).

---

## 2) Какие данные используются

### 2.1. Конфиг «сетки времени» (`ChronosConfig`)

Используются параметры:

- `start_hour` — с какого часа можно публиковать (например, 06:00)
- `end_hour` — до какого часа (например, 24:00)
- `step_minutes` — шаг слотов (например, 120 минут)
- `instant_publish` — аварийный режим «сразу»

Конфиг хранится в settings БД и меняется командами суперадмина.

### 2.2. Очередь постов

В очередь попадают посты со статусом `scheduled`. При одобрении поста бот:

- ставит статус `scheduled`
- дальше назначает `scheduled_at` (или сразу публикует, если включён instant)

### 2.3. История активности (для `dynamic`)

Чтобы оценивать «сколько постов в день обычно проходит», бот хранит историю одобрений по дням (`approvals`). Эти данные используются для прогноза, чтобы план не был «оторван от реальности».

---

## 3) Сетка слотов: как строятся возможные времена публикации

Основа всего — генератор слотов `slot_iterator(anchor, cfg)`.

Идея:

- есть **дневное окно** `[start_hour, end_hour)`
- внутри окна слоты каждые `step_minutes`
- стартуем с момента `anchor` (обычно `now`) и выдаём ближайшие слоты вперёд по дням

### 3.1. Округление «вперёд» до ближайшего слота

Если текущее время не совпадает со слотом — бот поднимается до следующего.

Пусть:

- $S$ — начало окна дня (например, 06:00 этого дня)
- $\Delta$ — шаг слота в минутах (`step_minutes`)
- $t$ — момент `anchor` (обычно «сейчас») в минутах относительно начала суток

Тогда индекс первого слота не раньше `anchor`:

$$k = \left\lceil \frac{t - S}{\Delta} \right\rceil$$

А сам слот:

$$\text{slot} = S + k\cdot\Delta$$

> Интуитивно: «сколько шагов по $\Delta$ надо сделать от старта дня, чтобы оказаться не раньше текущего времени».

### 3.2. Пример сетки

Конфиг: `start=06:00`, `end=24:00`, `step=120 мин`.

Слоты в день:

- 06:00, 08:00, 10:00, 12:00, 14:00, 16:00, 18:00, 20:00, 22:00

Если сейчас 13:20 — ближайший слот будет 14:00 (округление вверх).

---

## 4) Static-режим: «первый свободный слот»

В `static` всё просто:

1. Собираем множество уже занятых моментов `scheduled_at`.
2. Идём по слотам от `now` вперёд.
3. Первый слот, которого нет в `booked`, — назначаем.

**Плюсы:** предсказуемо, легко объяснить.

**Минусы:** нет «справедливости» по авторам и нет адаптации под очередь.

---

## 5) Dynamic-режим: «умная пересборка»

Динамический планировщик запускается при одобрении поста (и/или при смене режима/конфига) и может **перераскидать времена всей очереди**, чтобы расписание выглядело лучше целиком.

Ниже — основные шаги.

### 5.1. Обозначения

- $Q$ — размер очереди (сколько постов в отложке)
- $cap$ — «ёмкость дня»: сколько слотов в пределах окна за сутки
- $n_{day\_target}$ — целевое число постов в сутки (расчитанное)
- $n_{day}$ — фактический план на сутки (после сглаживания)
- $n_{today}$ — сколько постов планировать «на сегодня»
- $\lambda_{pred}$ — прогноз «обычно публикуем примерно столько-то в день» по истории

### 5.2. Ёмкость дня

Ёмкость дня оценивается по окну (`start_hour`, `end_hour`) и шагу (`step_minutes`). Это верхняя граница «сколько вообще можно запланировать на сутки».

На практике итог всё равно ограничивается реальным количеством слотов, сгенерированных сеткой.

### 5.3. «Эффективное ожидание» очереди

Планировщик смотрит, как давно лежит самый старый пост, но делает поправку на «спам одного автора».

1. Берётся время самого старого поста в очереди (по `approved_at` или `created_at`).
2. Считается ожидание в часах:

$$W_{hours} = \frac{now - oldest}{3600}$$

3. Считается максимальное число постов одного автора в очереди: $max\_pending\_author$.
4. Итоговая поправка:

$$W_{eff} = \frac{W_{hours}}{1 + \ln(1 + max\_pending\_author)}$$

Смысл: если очередь «старая» из-за того, что один автор накидал 50 постов, это не должно резко ускорять весь план.

### 5.4. Прогноз «сколько постов в день обычно проходит» (EWMA)

Берём историю одобрений за последние дни и считаем экспоненциально сглаженное среднее (EWMA).

Базовая формула EWMA:

$$EWMA_t = \alpha\cdot v_t + (1-\alpha)\cdot EWMA_{t-1}$$

Считается:

- $\lambda_{long}$ по 14 дням (обычно $\alpha=\frac{1}{14}$)
- $\lambda_{short}$ по 3 дням (обычно $\alpha=\frac{1}{3}$)

Комбинация:

$$\lambda_{pred} = 0.7\cdot\lambda_{short} + 0.3\cdot\lambda_{long}$$

### 5.5. Сигмоида (мягкие переходы)

Используется стандартная сигмоида:

$$\sigma(x) = \frac{1}{1 + e^{-x}}$$

Она нужна, чтобы избегать резких скачков («если очередь > N, то сразу максимум») и делать рост плавным.

### 5.6. Цель постов в сутки: $n_{day\_target}$

Есть две границы:

- $n_{softmax}=\min(10, cap)$ — комфортный предел
- $n_{hardmax}=cap$ — физический максимум слотов

Дальше:

1) **База по размеру очереди** (мягко растёт до $n_{softmax}$):

$$n_{soft} = 1 + (n_{softmax}-1)\cdot \sigma\left(\frac{Q - n_{softmax}}{0.25\cdot n_{softmax}}\right)$$

2) **Буст по ожиданию**:

$$boost = \sigma\left(\frac{W_{eff} - 22}{2.5}\right)$$

3) **Смешиваем к хардмаксу**, если очередь «залежалась»:

$$n_{day\_target} = n_{soft} + (n_{hardmax}-n_{softmax})\cdot boost$$

4) И не даём упасть ниже исторического прогноза:

$$n_{day\_target} = \max(n_{day\_target}, \lambda_{pred})$$

### 5.7. Сглаживание плана по дням

Планировщик хранит прошлое значение плана (условно `chronos_last_plan`) и сглаживает новые значения:

$$n_{smooth} = (1-\beta)\cdot n_{last} + \beta\cdot n_{day\_target}$$

где обычно $\beta=0.3$.

Итог на сутки:

$$n_{day} = clamp\big(1,\ \min(Q, n_{hardmax}),\ \mathrm{round}(n_{smooth})\big)$$

### 5.8. Сколько ставить на сегодня: $n_{today}$

Сначала считаем, сколько слотов осталось сегодня: $slots_{today}$.

Доля оставшихся слотов:

$$r = \frac{slots_{today}}{cap}$$

Переходная функция:

$$g_{today} = \sigma\left(\frac{r - 0.35}{0.10}\right)$$

База:

$$n_{today\_base} = \min\big(slots_{today},\ \mathrm{round}(n_{day}\cdot g_{today})\big)$$

Потом добавляется «подтягивание» маленькой очереди в первый день:

$$pull = \sigma\left(\frac{12 - Q}{3}\right)$$

Где $first\_day\_cap = \min(Q, slots_{today}, cap)$.

Смешивание:

$$n_{today} = \mathrm{round}\big(n_{today\_base}\cdot(1-pull) + first\_day\_cap\cdot pull\big)$$

И защита: если очередь есть и слоты есть, а получилось 0 — ставим хотя бы 1.

### 5.9. Горизонт планирования (на сколько дней вперёд)

Динамика выбирает, на сколько дней вперёд раскладывать очередь:

$$H_{days} = 0.25 + 6.75\cdot \sigma\left(\frac{Q - 20}{10}\right)$$

$$max\_days = \lceil H_{days} \rceil$$

Чем больше очередь — тем дальше раскладываем.

### 5.10. Выбор слотов внутри дня (равномерно)

Для каждого дня:

- берём список слотов $day\_slots$
- разрешено поставить $allowed$ постов (для сегодня — $n_{today}$, для будущих — дневная цель)
- выбираем $allowed$ слотов равномерно по индексу

Если $L = |day\_slots|$, то:

$$step = \frac{L}{allowed}$$

$$idx_i = \left\lfloor i\cdot step \right\rfloor,\ \ i=0..allowed-1$$

### 5.11. «Справедливость» между авторами: приоритет автора

Главная фишка динамики: **в каждый выбранный слот выбирается не просто “следующий пост”, а лучший автор** по приоритету.

Используются:

- $pending_u$ — сколько постов автора $u$ сейчас в очереди
- $recent_u$ — сколько раз автор встречается в последних $N$ публикациях (в коде $N=10$)
- $t_u$ — сколько часов прошло с последней публикации автора (если никогда не публиковался — считается большим)

Приоритет автора для данного слота:

$$prio(u)=\frac{\ln(1+t_u)}{1+\ln(1+pending_u)} - 0.3\cdot recent_u$$

Интуитивно:

- чем дольше автор не публиковался → тем выше приоритет
- чем больше автор «заспамил» очередь → тем ниже приоритет
- чем чаще был недавно → тем ниже приоритет

Дополнительно действует правило «не ставить одного и того же автора подряд», если есть альтернативы.

После выбора автора берётся **первый (самый ранний) пост этого автора** в очереди и назначается в текущий слот.

### 5.12. Финал: запись в БД и обновление админки

После назначения:

- всем назначенным постам обновляется `scheduled_at` и статус `scheduled`
- для каждого такого поста обновляется админ-сообщение (чтобы в модерации было видно новое время)


**Плюсы:** умно

**Минусы:** отсутствуют

